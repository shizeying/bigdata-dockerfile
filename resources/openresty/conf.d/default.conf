# nginx.vh.default.conf  --  docker-openresty
#
# This file is installed to:
#   `/etc/nginx/conf.d/default.conf`
#
# It tracks the `server` section of the upstream OpenResty's `nginx.conf`.
#
# This config (and any other configs in `etc/nginx/conf.d/`) is loaded by
# default by the `include` directive in `/usr/local/openresty/nginx/conf/nginx.conf`.
#
# See https://github.com/openresty/docker-openresty/blob/master/README.md#nginx-config-files
#



http {

	# 定义checkups需要的共享内存
	lua_shared_dict state 10m;
    lua_shared_dict mutex 1m;
    lua_shared_dict locks 1m;
    lua_shared_dict config 10m;


	keepalive_timeout  60;
	lua_package_path '$prefix/lua/?.lua;;';
	lua_package_cpath "$prefix/src/lualib/?.lua;;";

	#初始化checkups
	init_by_lua_block {
        local config = require "config"
        local checkups = require "resty.checkups.api"
        checkups.init(config)
    }
	#准备和创建心跳定时器和上游同步定时器
    init_worker_by_lua_block {
        local config = require "config"
        local checkups = require "resty.checkups.api"
        checkups.prepare_checker(config)
        checkups.create_checker()
    }

	# 动态上游集群
	upstream binghe_server{
		server 0.0.0.1; # 占位用，无实际意义

		# 执行负载均衡的 Lua 代码
		balancer_by_lua_block{
			local checkups = require "resty.checkups.api"
			local balancer = require "ngx.balancer";
			balancer.set_timeouts(1, 0.5, 0.5) -- 后端的连接和读写超时时间
			balancer.set_more_tries(2) 		   -- 连接失败后最多在重试 2 次

			local status, code = balancer.get_last_failure()  --获取上次失败信息
			if status == "failed" then
				local last_peer = ngx.ctx.last_peer
				ngx.log(ngx.ERR, "get_last_failure: ", last_peer);
				-- 标记上次失败server
				checkups.feedback_status("up_http", last_peer.host, last_peer.port, true)
			end
			local peer,err = checkups.select_peer("up_http") --根据算法从服务器列表中获取一个服务地址
			ngx.ctx.last_peer = peer	--记录这次连接server
			balancer.set_current_peer(peer.host, peer.port)
		}
		keepalive 10;  # 需在 balancer 指令之后
	}

	server {
		listen       8090;
		server_name  localhost;
		charset utf-8;

		location / {
			 proxy_pass http://binghe_server;
		}

		# 动态更新upstream集群，同时更新checkups配置文件
		# checkups.update_upstream接口是覆盖集群
		# 这里改为添加server到集群
		# 可根据情况自行更改
		location = /update_upstream {
			access_log off;
			allow 127.0.0.1;
			deny all;
			default_type text/plain;
			content_by_lua_block {
				local host = ngx.req.get_uri_args()["host"]
				local port = ngx.req.get_uri_args()["port"]
				local weight = ngx.req.get_uri_args()["weight"]

				if host == nil or port == nil then
                    ngx.say("usage: /update_upstream?host=x.x.x.x&port=x")
                    return
                end
				if type(port) == "string" then
					port= tonumber(port)
				end
				if weight == nil then
					weight = 10
				end
				local checkups = require "resty.checkups.api"
				local save_config = require "save_config"

				local ok = save_config.save_server(host,port,weight)
				if not ok then ngx.say("save server info error") end

				local upstream_data = checkups.get_upstream("up_http")
				local new_server = { host = host, port = port, weight=weight, max_fails=3, fail_timeout=10 }
				table.insert(upstream_data.cluster[1].servers,new_server)
				local ok, err = checkups.update_upstream("up_http", upstream_data)
                if err then ngx.say(err) end

				ngx.say("update upstream ok")
			}
		}

		# 动态删除upstream集群，同时更新checkups配置文件
		# checkups.delete_upstream接口是删除整个集群
		# 这里改为删除集群中指定server或者整个集群
		# 可根据情况自行更改
		location = /delete_upstream {
			access_log off;
			allow 127.0.0.1;
			deny all;
			default_type text/plain;
			content_by_lua_block {
				local host = ngx.req.get_uri_args()["host"]
				local port = ngx.req.get_uri_args()["port"]
				local skey = ngx.req.get_uri_args()["skey"]

				if (host == nil or port == nil) and skey == nil then
                    ngx.say("usage: /delete_upstream?host=x.x.x.x&port=x \nor\nusage: /delete_upstream?skey=x")
                    return
                end

				local checkups = require "resty.checkups.api"
				if skey ~= nil then
					local ok, err = checkups.delete_upstream(skey)
					if err then
						ngx.say(err)
					else
						ngx.say("ok")
					end
					return
				end

				if type(port) == "string" then
					port= tonumber(port)
				end

				local upstream_data = checkups.get_upstream("up_http")

				for i,v in ipairs(upstream_data.cluster[1].servers) do
					if v.host == host and v.port == port then
						table.remove(upstream_data.cluster[1].servers, i)
						local ok, err = checkups.update_upstream("up_http", upstream_data)
						if err then
							ngx.say(err)
						else
							local save_config = require "save_config"
							local ok = save_config.delete_server(port)
							if not ok then ngx.say("delete server info error") end

							ngx.say("delete upstream ok")
						end

						return
					end
				end

				ngx.say("failed")
			}
		}

		# 查看所有集群运行状态
		# 可根据情况自行更改
		location = /status {
			access_log off;
			allow 127.0.0.1;
			deny all;
			default_type application/json;
			content_by_lua_block {
				local cjson = require "cjson"
				local checkups = require "resty.checkups.api"
                ngx.say(cjson.encode(checkups.get_status()))
			}
		}
	}
}